#!/usr/bin/python

# This file is part of lagrangian library.
#
# lagrangian is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# lagrangian is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# lagrangian.  If not, see <http://www.gnu.org/licenses/>.

import lagrangian
import datetime
import netCDF4
import numpy
import argparse
import multiprocessing
import signal
import sys

# __________________________________________________________________________ #

def positive_value(value):
    """
    Check options for defining values strictly positive.
    """
    try:
        value = float(value)
    except ValueError:
        msg = "invalid float value: %r" % value
        raise argparse.ArgumentTypeError(msg)
    if value < 0:
        msg = "value must be positive: %f" % value
        raise argparse.ArgumentTypeError(msg)
    return value

# __________________________________________________________________________ #

def usage():
    """
    Program syntax
    """
    parser = argparse.ArgumentParser(description='Compute Map of FLE')
    parser.add_argument('configuration', help='Configuration file')
    parser.add_argument('fle', help='Map of FLE in NetCDF format')
    parser.add_argument('start_time', help='Start time')
    parser.add_argument('end_time', help='End time')
    parser.add_argument('--step',
                        help='Grid step in degrees',
                        type=positive_value,
                        default=1)
    parser.add_argument('--separation',
                        help='Minimum separation in degrees',
                        type=positive_value,
                        metavar='SEP',
                        default=-1)
    parser.add_argument('--delta',
                        help='Time delta in hours',
                        type=positive_value,
                        default=6)
    parser.add_argument('--x_min',
                        help='X min in degrees',
                        type=float,
                        default=-180)
    parser.add_argument('--x_max',
                        help='X max in degrees',
                        type=float,
                        default=180)
    parser.add_argument('--y_min',
                        help='Y min in degrees',
                        type=float,
                        default=-90)
    parser.add_argument('--y_max',
                        help='Y max in degrees',
                        type=float,
                        default=90)
    return parser.parse_args()

# __________________________________________________________________________ #

def convert_from_sec_to_day(a, fill_value):
    """
    Converting values from second to days
    """
    result = numpy.ma.masked_equal(a, fill_value)
    result *= 86400
    return result.data

# __________________________________________________________________________ #

def main():
    """
    Main function
    """
    # Initializes arguments from command line
    args = usage()
    
    # Check X & Y range
    if not args.x_min < args.x_max:
        raise RuntimeError("Invalid definition of x range.")
    if not args.y_min < args.y_max:
        raise RuntimeError("Invalid definition of y range.")

    # Fill value for double in NetCDF file
    NC_FILL_DOUBLE = 9.9692099683868690e+36

    # Initializes the time series to process
    ts = lagrangian.TimeSerieField(args.configuration)
    delta = datetime.timedelta(0, args.delta * 60 * 60)

    start_time = lagrangian.JulianDay(args.start_time)
    end_time = lagrangian.JulianDay(args.end_time)

    nx = int((args.x_max - args.x_min) / args.step)
    ny = int((args.y_max - args.y_min) / args.step)

    # Initializes calculation mode
    mode = lagrangian.kFTLE if args.separation < 0 else lagrangian.kFSLE
    caption = 'FTLE' if args.separation < 0 else 'FSLE'

    # Initializes the map to process
    map_of_fle = lagrangian.MapOfFiniteLyapunovExponents(nx,
                                                         ny,
                                                         args.x_min,
                                                         args.y_min,
                                                         args.step)

    # Initializes the FLE to process
    fle = lagrangian.FiniteLyapunovExponents(start_time,
                                             end_time,
                                             delta,
                                             mode,
                                             args.separation,
                                             args.step,
                                             ts)

    # Computes map
    map_of_fle.Compute(fle)

    # Creates the NetCDF file
    rootgrp = netCDF4.Dataset(args.fle, 'w', format='NETCDF4')
    rootgrp.createDimension('x', nx)
    rootgrp.createDimension('y', ny)
    rootgrp.title = 'Map of %s' % caption
    if args.separation > 0:
        rootgrp.separation = ('Minimum separation (expansion) in degrees: %f'
                              % (args.separation))
    rootgrp.start_time = start_time.ToString("%Y-%m-%d %T")
    rootgrp.end_time = end_time.ToString("%Y-%m-%d %T")

    x_axis = rootgrp.createVariable('x', 'f8', ('x',))
    x_axis.units = 'degrees_east'
    x_axis[:] = map_of_fle.get_map_properties().GetXAxis()

    y_axis = rootgrp.createVariable('y', 'f8', ('y',))
    y_axis.units = 'degrees_north'
    y_axis[:] = map_of_fle.get_map_properties().GetYAxis()

    theta1 = rootgrp.createVariable('theta1',
                                    'f8',
                                    ('x', 'y',),
                                    fill_value=NC_FILL_DOUBLE)
    theta1.long_name = 'theta1'
    theta1.units = 'degrees'
    theta1[:] = map_of_fle.GetMapOfTheta1(NC_FILL_DOUBLE, fle)

    theta2 = rootgrp.createVariable('theta2',
                                    'f8',
                                    ('x', 'y',),
                                    fill_value=NC_FILL_DOUBLE)
    theta2.long_name = 'theta2'
    theta2.units = 'degrees'
    theta2[:] = map_of_fle.GetMapOfTheta2(NC_FILL_DOUBLE, fle)

    lambda1 = rootgrp.createVariable('lambda1',
                                     'f8',
                                     ('x', 'y',),
                                     fill_value=NC_FILL_DOUBLE)
    lambda1.long_name = 'lambda1'
    lambda1.units = '1/day'
    lambda1[:] = convert_from_sec_to_day(
        map_of_fle.GetMapOfLambda1(NC_FILL_DOUBLE, fle), NC_FILL_DOUBLE)

    lambda2 = rootgrp.createVariable('lambda2', 'f8', ('x', 'y',),
                                     fill_value=NC_FILL_DOUBLE)
    lambda2.long_name = 'lambda2'
    lambda2.units = '1/day'
    lambda2[:] = convert_from_sec_to_day(
        map_of_fle.GetMapOfLambda2(NC_FILL_DOUBLE, fle), NC_FILL_DOUBLE)
    rootgrp.close()

# __________________________________________________________________________ #

def signal_handler(signum, _):
    """
    Signal handler
    """
    signame = {}
    for value, key in signal.__dict__.iteritems():
        if value.startswith('SIG'):
            signame[key] = value
    print 'Stop with signal %s' % signame[signum]
    for process in multiprocessing.process.active_children():
        process.terminate()
    sys.exit(0)

# __________________________________________________________________________ #

if __name__ == '__main__':
    
    # Initialize signal handler
    signal.signal(signal.SIGINT, signal_handler)

    # As the calculation is long, the calculation process is started in
    # parallel. Thus the user can stop the program
    PROCESS = multiprocessing.Process(target=main)
    PROCESS.start()
    PROCESS.join()
