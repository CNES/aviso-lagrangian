#!/usr/bin/env python

# This file is part of lagrangian library.
#
# lagrangian is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# lagrangian is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# lagrangian.  If not, see <http://www.gnu.org/licenses/>.

import lagrangian
import datetime
import netCDF4
import numpy
import argparse
import multiprocessing
import signal
import sys


SYSTEM_UNITS = {
    "metric": lagrangian.kMetric,
    "angular": lagrangian.kAngular
}


STENCIL = {
    "triplet": lagrangian.kTriplet,
    "quintuplet": lagrangian.kQuintuplet
}


def positive_value(value):
    """
    Check options for defining values strictly positive.
    """
    try:
        value = float(value)
    except ValueError:
        msg = "invalid float value: %r" % value
        raise argparse.ArgumentTypeError(msg)
    if value < 0:
        msg = "value must be positive: %f" % value
        raise argparse.ArgumentTypeError(msg)
    return value


def usage():
    """
    Program syntax
    """
    parser = argparse.ArgumentParser(description='Compute Map of FLE',
                                     add_help=False)
    grid = parser.add_argument_group('grid arguments',
                                     'Set the grid properties to create')
    grid.add_argument('--step',
                      help='grid step in degrees',
                      type=positive_value,
                      default=1)
    grid.add_argument('--x_min',
                      help='x min in degrees',
                      type=float,
                      default=-180)
    grid.add_argument('--x_max',
                      help='x max in degrees',
                      type=float,
                      default=180)
    grid.add_argument('--y_min',
                      help='y min in degrees',
                      type=float,
                      default=-90)
    grid.add_argument('--y_max',
                      help='y max in degrees',
                      type=float,
                      default=90)

    integration = parser.add_argument_group('integration arguments',
                                            'Define integration')
    integration.add_argument('--stencil',
                             help='type of stencil used to compute the finite '
                                  'difference.',
                             choices=STENCIL.keys(),
                             default="triplet")
    integration.add_argument('--initial_separation',
                             help='initial separation in degrees of '
                                  'neighbouring particules (by default, this '
                                  'option is set with the value of the option '
                                  '--step)',
                             type=positive_value,
                             metavar='DELTA',
                             default=None)
    integration.add_argument('--final_separation',
                             help='maximum final separation in degrees',
                             type=positive_value,
                             metavar='DELTA',
                             default=-1)
    integration.add_argument('--delta',
                             help='time delta in hours',
                             type=positive_value,
                             default=6)

    data = parser.add_argument_group('reader arguments',
                                     'Set options of the NetCDF reader.')
    data.add_argument('--unit',
                      help='system of units for velocity',
                      choices=SYSTEM_UNITS.keys(),
                      default="metric")
    data.add_argument('--mask',
                      help='netCDF grid for fixing undefined cells',
                      nargs=2,
                      metavar=('PATH', 'VARNAME'))

    parser.add_argument('--verbose',
                        help='Verbose mode',
                        action='store_true')
    parser.add_argument('--version',
                        help='print the version number and exit',
                        action='store_true')

    args, _ = parser.parse_known_args()
    if args.version:
        print(lagrangian.Version())
        sys.exit(0)

    parser.add_argument('--help', '-h',
                        action='help',
                        default=argparse.SUPPRESS,
                        help='show this help message and exit')
    parser.add_argument('configuration', help='configuration file')
    parser.add_argument('fle', help='map of FLE in NetCDF format')
    parser.add_argument('start_time', help='start of the integration')
    parser.add_argument('end_time', help='end of the integration')

    return parser.parse_args()


def convert_from_sec_to_day(a, fill_value):
    """
    Converting values from second to days
    """
    result = numpy.ma.masked_equal(a, fill_value)
    result *= 86400
    return result.data


def main():
    """
    Main function
    """
    # Initializes arguments from command line
    args = usage()

    # Set debug
    lagrangian.set_verbose(args.verbose)

    # Check X & Y range
    if not args.x_min < args.x_max:
        raise RuntimeError("Invalid definition of x range.")
    if not args.y_min < args.y_max:
        raise RuntimeError("Invalid definition of y range.")

    # Fill value for double in NetCDF file
    NC_FILL_DOUBLE = 9.9692099683868690e+36

    # Initializes the time series to process
    ts = lagrangian.TimeSerie(args.configuration,
                              SYSTEM_UNITS[args.unit])
    delta = datetime.timedelta(0, args.delta * 60 * 60)

    start_time = lagrangian.DateTime(args.start_time)()
    end_time = lagrangian.DateTime(args.end_time)()

    if start_time < ts.start_time():
        raise RuntimeError("The start date (%s) is before the beginning "
                           "of the time series (%s)" %
                           (start_time.strftime("%Y-%m-%dT%H:%M:%S"),
                            ts.start_time().strftime("%Y-%m-%dT%H:%M:%S")))

    if end_time > ts.end_time():
        raise RuntimeError("The end date (%s) is after the ending "
                           "of the time series (%s)" %
                           (end_time.strftime("%Y-%m-%dT%H:%M:%S"),
                            ts.end_time().strftime("%Y-%m-%dT%H:%M:%S")))
    nx = int((args.x_max - args.x_min) / args.step)
    ny = int((args.y_max - args.y_min) / args.step)

    # By default the initial separation is the grid step
    if args.initial_separation is None:
        args.initial_separation = args.step

    # Initializes calculation mode
    mode = lagrangian.kFTLE if args.final_separation < 0 else lagrangian.kFSLE
    caption = 'FTLE' if args.final_separation < 0 else 'FSLE'

    # Build the map properties
    map_properties = lagrangian.MapProperties(
        nx,
        ny,
        args.x_min,
        args.y_min,
        args.step)

    # Initializes the FLE to process
    fle = lagrangian.FiniteLyapunovExponents(start_time,
                                             end_time,
                                             delta,
                                             mode,
                                             args.final_separation,
                                             args.initial_separation,
                                             ts)

    # The nodes of the grid result, located on land are undefined. To speed
    # up the calculation we use a external grid to remove these cells from
    # the calculation.
    if args.mask:
        reader = lagrangian.NetcdfReader()
        reader.Open(args.mask[0])
        reader.Load(args.mask[1])
    else:
        reader = None

    # Initializes the map to process
    map_of_fle = lagrangian.MapOfFiniteLyapunovExponents(
        map_properties,
        fle,
        STENCIL[args.stencil],
        reader)

    # Computes map
    map_of_fle.compute()

    # Creates the NetCDF file
    rootgrp = netCDF4.Dataset(args.fle, 'w', format='NETCDF4')
    rootgrp.createDimension('x', nx)
    rootgrp.createDimension('y', ny)
    rootgrp.title = 'Map of %s' % caption
    if args.final_separation > 0:
        rootgrp.separation = ('Minimum separation (expansion) in degrees: %f'
                              % (args.final_separation))
    rootgrp.start_time = start_time.strftime("%Y-%m-%d %T")
    rootgrp.end_time = end_time.strftime("%Y-%m-%d %T")

    x_axis = rootgrp.createVariable('x', 'f8', ('x',))
    x_axis.units = 'degrees_east'
    x_axis[:] = map_properties.get_x_axis()

    y_axis = rootgrp.createVariable('y', 'f8', ('y',))
    y_axis.units = 'degrees_north'
    y_axis[:] = map_properties.get_y_axis()

    theta1 = rootgrp.createVariable('theta1',
                                    'f8',
                                    ('x', 'y',),
                                    fill_value=NC_FILL_DOUBLE)
    theta1.long_name = 'FLE associated to the maximum eigenvalues of ' \
        'Cauchy-Green strain tensor'
    theta1.units = 'degrees'
    theta1[:] = map_of_fle.get_map_of_theta1(NC_FILL_DOUBLE)

    theta2 = rootgrp.createVariable('theta2',
                                    'f8',
                                    ('x', 'y',),
                                    fill_value=NC_FILL_DOUBLE)
    theta2.long_name = 'FLE associated to the minimum eigenvalues of ' \
        'Cauchy-Green strain tensor'
    theta2.units = 'degrees'
    theta2[:] = map_of_fle.get_map_of_theta1(NC_FILL_DOUBLE)

    lambda1 = rootgrp.createVariable('lambda1',
                                     'f8',
                                     ('x', 'y',),
                                     fill_value=NC_FILL_DOUBLE)
    lambda1.long_name = 'Orientation of the eigenvectors associated to the' \
        'maximum eigenvalues of Cauchy-Green strain tensor'
    lambda1.units = '1/day'
    lambda1[:] = convert_from_sec_to_day(
        map_of_fle.get_map_of_lambda1(NC_FILL_DOUBLE), NC_FILL_DOUBLE)

    lambda2 = rootgrp.createVariable('lambda2', 'f8', ('x', 'y',),
                                     fill_value=NC_FILL_DOUBLE)
    lambda2.long_name = 'Orientation of the eigenvectors associated to the' \
        'minimum eigenvalues of Cauchy-Green strain tensor'
    lambda2.units = '1/day'
    lambda2[:] = convert_from_sec_to_day(
        map_of_fle.get_map_of_lambda2(NC_FILL_DOUBLE), NC_FILL_DOUBLE)
    rootgrp.close()


def signal_handler(signum, _):
    """
    Signal handler
    """
    signame = {}
    for value, key in signal.__dict__.items():
        if value.startswith('SIG'):
            signame[key] = value
    print('Stop with signal %s' % signame[signum])
    for process in multiprocessing.process.active_children():
        process.terminate()
    sys.exit(0)


if __name__ == '__main__':

    # Initialize signal handler
    signal.signal(signal.SIGINT, signal_handler)

    # As the calculation is long, the calculation process is started in
    # parallel. Thus the user can stop the program
    PROCESS = multiprocessing.Process(target=main)
    PROCESS.start()
    PROCESS.join()
