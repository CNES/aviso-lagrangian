# This file is part of lagrangian library.
#
# lagrangian is free software: you can redistribute it and/or modify
# it under the terms of GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# lagrangian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of GNU Lesser General Public License
# along with lagrangian. If not, see <http://www.gnu.org/licenses/>.
import typing
from typing import ClassVar, overload

import numpy
import numpy.typing

class Advect:
    def __init__(self, nx: typing.SupportsInt, ny: typing.SupportsInt, x_min: typing.SupportsFloat, y_min: typing.SupportsFloat, step: typing.SupportsFloat) -> None: ...
    def Initialize(self, integration: Integration, field: Reader | None = ...) -> None: ...
    def compute(self, integration: Integration, num_threads: typing.SupportsInt = ...) -> None: ...
    def map_of_x(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...
    def map_of_y(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...

class CellProperties:
    def __init__(self) -> None: ...
    @staticmethod
    def none() -> CellProperties: ...

class CoordinatesType:
    __members__: ClassVar[dict] = ...  # read-only
    CARTESIAN: ClassVar[CoordinatesType] = ...
    SPHERICAL_EQUATORIAL: ClassVar[CoordinatesType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DateTime:
    def __init__(self, arg0) -> None: ...
    def to_datetime(self, *args, **kwargs): ...

class Field:
    def __init__(self, unit_type: UnitType, coordinate_type: CoordinatesType = ...) -> None: ...
    def compute(self, t, x: typing.SupportsFloat, y: typing.SupportsFloat, cell: CellProperties = ...) -> object: ...
    def fetch(self, first, last) -> None: ...
    def unit(self) -> str: ...
    @property
    def coordinate_type(self) -> CoordinatesType: ...
    @property
    def unit_type(self) -> UnitType: ...

class FiniteLyapunovExponents:
    delta_t: float
    final_separation: float
    lambda1: float
    lambda2: float
    theta1: float
    theta2: float
    def __init__(self) -> None: ...

class FiniteLyapunovExponentsIntegration(Integration):
    def __init__(self, start_time, end_time, delta_t, mode: IntegrationMode, min_sepration: typing.SupportsFloat, delta: typing.SupportsFloat, field: Field = ...) -> None: ...
    def compute(self, it: Iterator, position: Position, cell: CellProperties) -> bool: ...  # type: ignore[override]
    def exponents(self, position: Position, fsle: FiniteLyapunovExponents) -> bool: ...
    def separation(self, position: Position) -> bool: ...
    def set_initial_point(self, x: typing.SupportsFloat, y: typing.SupportsFloat, stencil: Stencil, spherical_equatorial: bool = ...) -> Position: ...
    @property
    def mode(self) -> IntegrationMode: ...

class Integration:
    def __init__(self, start_time, end_time, delta_t, field: Field) -> None: ...
    def compute(self, it: Iterator, x0: typing.SupportsFloat, y0: typing.SupportsFloat) -> object: ...
    def fetch(self, date) -> None: ...
    def iterator(self) -> Iterator: ...

class IntegrationMode:
    __members__: ClassVar[dict] = ...  # read-only
    FSLE: ClassVar[IntegrationMode] = ...
    FTLE: ClassVar[IntegrationMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Iterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __next__(self): ...

class MapOfFiniteLyapunovExponents:
    def __init__(self, map_properties: MapProperties, fle: FiniteLyapunovExponentsIntegration, stencil: Stencil = ..., reader: Reader = ...) -> None: ...
    def compute(self, num_threads: typing.SupportsInt = ...) -> None: ...
    def map_of_delta_t(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...
    def map_of_final_separation(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...
    def map_of_lambda1(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...
    def map_of_lambda2(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...
    def map_of_theta1(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...
    def map_of_theta2(self, fill_value: typing.SupportsFloat = ...) -> numpy.typing.NDArray[numpy.float64]: ...

class MapProperties:
    def __init__(self, nx: typing.SupportsInt, ny: typing.SupportsInt, x_min: typing.SupportsFloat, y_min: typing.SupportsFloat, step: typing.SupportsFloat) -> None: ...
    def x_axis(self) -> numpy.typing.NDArray[numpy.float64]: ...
    def y_axis(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def nx(self) -> int: ...
    @property
    def ny(self) -> int: ...
    @property
    def step(self) -> float: ...
    @property
    def x_min(self) -> float: ...
    @property
    def y_min(self) -> float: ...

class Path(Integration):
    def __init__(self, start_time, end_time, delta_t, field: Field) -> None: ...

class Position:
    missing: None
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, start_time, spherical_equatorial: bool = ...) -> None: ...
    def compute(self, rk4: RungeKutta, it: Iterator, cell: CellProperties) -> bool: ...
    def max_distance(self) -> float: ...
    def strain_tensor(self) -> tuple: ...
    def xi(self) -> numpy.typing.NDArray[numpy.float64]: ...
    def yi(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def is_completed(self) -> bool: ...
    @property
    def time(self): ...

class Quintuplet(Position):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: typing.SupportsFloat, y: typing.SupportsFloat, delta: typing.SupportsFloat, start_time, spherical_equatorial: bool = ...) -> None: ...

class Reader:
    def __init__(self) -> None: ...

class RungeKutta:
    def __init__(self, arg0: typing.SupportsFloat, arg1: Field) -> None: ...
    def compute(self, t, x: typing.SupportsFloat, y: typing.SupportsFloat, cell: CellProperties = ...) -> tuple: ...

class Stencil:
    __members__: ClassVar[dict] = ...  # read-only
    QUINTUPLET: ClassVar[Stencil] = ...
    TRIPLET: ClassVar[Stencil] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimeDuration:
    def __init__(self, arg0) -> None: ...
    def to_timedelta(self, *args, **kwargs): ...

class Triplet(Position):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: typing.SupportsFloat, y: typing.SupportsFloat, delta: typing.SupportsFloat, start_time, spherical_equatorial: bool = ...) -> None: ...

class UnitType:
    __members__: ClassVar[dict] = ...  # read-only
    ANGULAR: ClassVar[UnitType] = ...
    METRIC: ClassVar[UnitType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def debug(message: str) -> None: ...
def set_verbose(value: bool) -> None: ...
def version() -> str: ...
